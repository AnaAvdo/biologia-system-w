# -*- coding: utf-8 -*-
"""bs_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LhY4hOJtryohkHYOrwfbIjLQOo1wwxGj
"""

import math
import copy
import statistics
from srodowisko import Srodowisko


class FisherModelSimulation:
    def __init__(self, params):
        self.params = params
        self.historia_populacji = []
        self.optima = []
        self.min_fitness = 0.3
        self.max_age = 6


    def run_simulation(self):

      srodowisko = Srodowisko(self.params)

      # [srodowisko w kroku[osobniki w wierszach[[cecha[1], ..., cecha[i]], płeć]]]
      historia_populacji = []
      kroki_katastrofy = []
      optima = []

      # pętla czasowa
      for krok in range(self.params['num_steps']):
        
        # Lista do obiektów nowych osobników 
        urodzone_w_kroku = []
  
        for osobnik in srodowisko.populacja:
          # Dla każdego osobnika w populacji przeprowadź następujące kroki:

          # 1. Mutacja (mutuje jeden losowy gen)
          osobnik.mutacja(self.params['mutation_probability'], self.params['num_genes'], self.params['mutation_effect'])

          # 2. Oblicz fitness danego osobnika w obecnym środowisku
          fitness = srodowisko.oblicz_fitness(osobnik.cechy_genotypu, self.params['fitness_coefficient'])

          # 3. Selekcja (po fitness i wieku). Jeśli osobnik zmarł, przejdź do następnego osobnika w pętli
          if fitness <= self.min_fitness or osobnik.wiek > self.max_age:
            srodowisko.populacja.remove(osobnik)
            continue

          # 4. Reprodukcja
          # Jeśli osobnik przeżył selekcję i w środowisku jest miejsce na kolejnych - przeprowadź rozród
          if len(srodowisko.populacja) < (srodowisko.max_pop - len(urodzone_w_kroku)):

            if osobnik.repr == 'klonowanie':
            # reprodukcja bezpłciowa, klonowanie
              if fitness > self.min_fitness:
                # Stwórz obiekty nowych osobników i przechowaj w liści dla nowych urodzonych 
                # Liczba potomków jest uzależniona od wartości fitness: przy maksymalnej ilości dzieci = 7 każdy osobnik może urodzić od 2 do 7 dzieci (min fitness >0.3, max fitness =1)
                for i in range(math.floor(fitness*self.params['max_num_children'])):
                  urodzone_w_kroku.append(copy.deepcopy(osobnik))


            else:
          # reprodukcja płciowa, non-random mating, zakładamy, że każdy może spotkać się z każdym, osobniki tworzą jedną parę na krok czasowy
          # preferencja płci 0 -> druga współrzędna płci 1 < 0.8. Jeśli takiego osobnika brak, bierze z najmniejszą drugą współrzędną
          # W efekcie dojdzie do kompromisu pomiędzy dostosowaniem a non-random mating

              znaleziono = 0
              # stwórz listę ze wszystkimi osobnikami płci 1:
              pula_1 = [os for os in srodowisko.populacja if os.płeć==1]

              if osobnik.płeć == 0:

              # Do badania braku preferencji:
                # Wybierz jakiegokolwiek osobnika z puli dostępnych
                # os_1 = pula_1.pop()
                # fitness_partnera = srodowisko.oblicz_fitness(os_1.cechy_genotypu, self.params['fitness_coefficient'])
                # for i in range(math.floor(statistics.mean([fitness, fitness_partnera])*self.params['max_num_children'])):
                #   urodzone_w_kroku.append(osobnik.reprodukuj(os_1, self.params))

                for os_1 in pula_1:
                  # Wybierz najkorzystniejszego osobnika z puli dostępnych
                  if os_1.cechy_genotypu[1] < 0.8:
                    znaleziono = 1
                    fitness_partnera = srodowisko.oblicz_fitness(os_1.cechy_genotypu, self.params['fitness_coefficient'])
                    for i in range(2+math.floor(statistics.mean([fitness, fitness_partnera])*self.params['max_num_children'])):
                      urodzone_w_kroku.append(osobnik.reprodukuj(os_1, self.params))
                    pula_1.remove(os_1)
                    break
                # Jeśli brak preferowanych - wybiej najbliższy preferowanemu genotyp z puli 
                if znaleziono == 0:
                  wybrany_os = None
                  for os_1 in pula_1:
                    cur_min = float('inf')
                    if os_1.cechy_genotypu[1] < cur_min:
                      cur_min = os_1.cechy_genotypu[1]
                      wybrany_os = os_1
                  fitness_partnera = srodowisko.oblicz_fitness(wybrany_os.cechy_genotypu, self.params['fitness_coefficient'])
                  for i in range(math.floor(statistics.mean([fitness, fitness_partnera])*self.params['max_num_children'])):
                    urodzone_w_kroku.append(osobnik.reprodukuj(wybrany_os, self.params))
          osobnik.wiek += 1


        # Zmiana środowiska - rak na krok czasowy

        # katastrofa
        if (self.params['scenario'] == 'meteor') or (self.params['scenario'] == 'mixed_gw_m'):
          if self.params["meteor_impact_strategy"] == 0:
            pass
          elif self.params["meteor_impact_strategy"] == 1:
            if krok % self.params['meteor_impact_every'] == 0:
              kroki_katastrofy.append(krok)
              srodowisko.katastrofa(self.params['global_warming_scale'])
          else: 
            if krok in self.params['meteor_impact_at']:
              kroki_katastrofy.append(krok)
              srodowisko.katastrofa(self.params['global_warming_scale'])


        # Regularne ocieplenie 
        if (self.params['scenario'] == 'mixed_gw_m') or (self.params['scenario'] == 'global warming'):
          srodowisko.optimum = srodowisko.zmiana_srodowiska(self.params['global_warming_scale'])

        # Zachowaj optima każdego kroku, żeby pokazać to na wykresie
        opt_w_kroku = [round(opt, 3) for opt in srodowisko.get_optimum()]
        optima.append(opt_w_kroku)

        # Zachowaj cechy populacji (genotym i płeć każdego osobnika) w danym kroku do wykresu
        populacja_w_kroku = []
        for os in srodowisko.populacja:
          populacja_w_kroku.append([[gen for gen in os.cechy_genotypu], os.płeć])
        historia_populacji.append(populacja_w_kroku)

        # Dodaj urodzonych w danym kroku do populacji
        srodowisko.populacja += urodzone_w_kroku

      # Zwróć historię populacji 
      self.historia_populacji = historia_populacji
      self.optima = optima
      return (self.historia_populacji, kroki_katastrofy, self.optima)
